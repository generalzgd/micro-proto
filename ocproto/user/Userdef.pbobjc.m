// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: user/userdef.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "user/Userdef.pbobjc.h"
#import "comm/Common.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - UserUserdefRoot

@implementation UserUserdefRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - UserUserdefRoot_FileDescriptor

static GPBFileDescriptor *UserUserdefRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"user"
                                                 objcPrefix:@"User"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum UserIdent

GPBEnumDescriptor *UserIdent_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Normal\000Official\000System\000";
    static const int32_t values[] = {
        UserIdent_Normal,
        UserIdent_Official,
        UserIdent_System,
    };
    static const char *extraTextFormatInfo = "\003\000&\000\001(\000\002&\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(UserIdent)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:UserIdent_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL UserIdent_IsValidValue(int32_t value__) {
  switch (value__) {
    case UserIdent_Normal:
    case UserIdent_Official:
    case UserIdent_System:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - UserGetUserInfoRequest

@implementation UserGetUserInfoRequest

@dynamic targetUidArray, targetUidArray_Count;
@dynamic traceId;
@dynamic thirdGameId;

typedef struct UserGetUserInfoRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t thirdGameId;
  GPBUInt32Array *targetUidArray;
  NSString *traceId;
} UserGetUserInfoRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetUidArray",
        .dataTypeSpecific.className = NULL,
        .number = UserGetUserInfoRequest_FieldNumber_TargetUidArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UserGetUserInfoRequest__storage_, targetUidArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "traceId",
        .dataTypeSpecific.className = NULL,
        .number = UserGetUserInfoRequest_FieldNumber_TraceId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserGetUserInfoRequest__storage_, traceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "thirdGameId",
        .dataTypeSpecific.className = NULL,
        .number = UserGetUserInfoRequest_FieldNumber_ThirdGameId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserGetUserInfoRequest__storage_, thirdGameId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserGetUserInfoRequest class]
                                     rootClass:[UserUserdefRoot class]
                                          file:UserUserdefRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserGetUserInfoRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\007\000\003\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserGetUserInfoReply

@implementation UserGetUserInfoReply

@dynamic code;
@dynamic message;
@dynamic userArray, userArray_Count;
@dynamic traceid;
@dynamic thirdAccount, thirdAccount_Count;

typedef struct UserGetUserInfoReply__storage_ {
  uint32_t _has_storage_[1];
  CommErrorType code;
  NSString *message;
  NSMutableArray *userArray;
  NSString *traceid;
  NSMutableDictionary *thirdAccount;
} UserGetUserInfoReply__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.enumDescFunc = CommErrorType_EnumDescriptor,
        .number = UserGetUserInfoReply_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserGetUserInfoReply__storage_, code),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "message",
        .dataTypeSpecific.className = NULL,
        .number = UserGetUserInfoReply_FieldNumber_Message,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserGetUserInfoReply__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userArray",
        .dataTypeSpecific.className = GPBStringifySymbol(UserInfo),
        .number = UserGetUserInfoReply_FieldNumber_UserArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UserGetUserInfoReply__storage_, userArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "traceid",
        .dataTypeSpecific.className = NULL,
        .number = UserGetUserInfoReply_FieldNumber_Traceid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserGetUserInfoReply__storage_, traceid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "thirdAccount",
        .dataTypeSpecific.className = NULL,
        .number = UserGetUserInfoReply_FieldNumber_ThirdAccount,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UserGetUserInfoReply__storage_, thirdAccount),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserGetUserInfoReply class]
                                     rootClass:[UserUserdefRoot class]
                                          file:UserUserdefRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserGetUserInfoReply__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\005\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UserGetUserInfoReply_Code_RawValue(UserGetUserInfoReply *message) {
  GPBDescriptor *descriptor = [UserGetUserInfoReply descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserGetUserInfoReply_FieldNumber_Code];
  return GPBGetMessageInt32Field(message, field);
}

void SetUserGetUserInfoReply_Code_RawValue(UserGetUserInfoReply *message, int32_t value) {
  GPBDescriptor *descriptor = [UserGetUserInfoReply descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserGetUserInfoReply_FieldNumber_Code];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - UserGetUserPLevelRequest

@implementation UserGetUserPLevelRequest

@dynamic targetUid;
@dynamic traceId;

typedef struct UserGetUserPLevelRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t targetUid;
  NSString *traceId;
} UserGetUserPLevelRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "targetUid",
        .dataTypeSpecific.className = NULL,
        .number = UserGetUserPLevelRequest_FieldNumber_TargetUid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserGetUserPLevelRequest__storage_, targetUid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "traceId",
        .dataTypeSpecific.className = NULL,
        .number = UserGetUserPLevelRequest_FieldNumber_TraceId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserGetUserPLevelRequest__storage_, traceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserGetUserPLevelRequest class]
                                     rootClass:[UserUserdefRoot class]
                                          file:UserUserdefRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserGetUserPLevelRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserGetUserPLevelReply

@implementation UserGetUserPLevelReply

@dynamic code;
@dynamic message;
@dynamic hasLevel, level;
@dynamic traceId;

typedef struct UserGetUserPLevelReply__storage_ {
  uint32_t _has_storage_[1];
  CommErrorType code;
  NSString *message;
  UserPLevelInfo *level;
  NSString *traceId;
} UserGetUserPLevelReply__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.enumDescFunc = CommErrorType_EnumDescriptor,
        .number = UserGetUserPLevelReply_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserGetUserPLevelReply__storage_, code),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "message",
        .dataTypeSpecific.className = NULL,
        .number = UserGetUserPLevelReply_FieldNumber_Message,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserGetUserPLevelReply__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "level",
        .dataTypeSpecific.className = GPBStringifySymbol(UserPLevelInfo),
        .number = UserGetUserPLevelReply_FieldNumber_Level,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserGetUserPLevelReply__storage_, level),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "traceId",
        .dataTypeSpecific.className = NULL,
        .number = UserGetUserPLevelReply_FieldNumber_TraceId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UserGetUserPLevelReply__storage_, traceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserGetUserPLevelReply class]
                                     rootClass:[UserUserdefRoot class]
                                          file:UserUserdefRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserGetUserPLevelReply__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UserGetUserPLevelReply_Code_RawValue(UserGetUserPLevelReply *message) {
  GPBDescriptor *descriptor = [UserGetUserPLevelReply descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserGetUserPLevelReply_FieldNumber_Code];
  return GPBGetMessageInt32Field(message, field);
}

void SetUserGetUserPLevelReply_Code_RawValue(UserGetUserPLevelReply *message, int32_t value) {
  GPBDescriptor *descriptor = [UserGetUserPLevelReply descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserGetUserPLevelReply_FieldNumber_Code];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - UserPLevelInfo

@implementation UserPLevelInfo

@dynamic level;
@dynamic exp;
@dynamic left;

typedef struct UserPLevelInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t level;
  uint32_t exp;
  uint32_t left;
} UserPLevelInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "level",
        .dataTypeSpecific.className = NULL,
        .number = UserPLevelInfo_FieldNumber_Level,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserPLevelInfo__storage_, level),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "exp",
        .dataTypeSpecific.className = NULL,
        .number = UserPLevelInfo_FieldNumber_Exp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserPLevelInfo__storage_, exp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "left",
        .dataTypeSpecific.className = NULL,
        .number = UserPLevelInfo_FieldNumber_Left,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserPLevelInfo__storage_, left),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserPLevelInfo class]
                                     rootClass:[UserUserdefRoot class]
                                          file:UserUserdefRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserPLevelInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserInfo

@implementation UserInfo

@dynamic uid;
@dynamic nickname;
@dynamic avatar;
@dynamic gender;
@dynamic ident;
@dynamic hasPlevel, plevel;
@dynamic anchor;
@dynamic mobile;
@dynamic inviteCode;

typedef struct UserInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t uid;
  uint32_t gender;
  UserIdent ident;
  NSString *nickname;
  NSString *avatar;
  UserPLevelInfo *plevel;
  NSString *mobile;
  NSString *inviteCode;
} UserInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uid",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_Uid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserInfo__storage_, uid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "nickname",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_Nickname,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserInfo__storage_, nickname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatar",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_Avatar,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserInfo__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gender",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_Gender,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UserInfo__storage_, gender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ident",
        .dataTypeSpecific.enumDescFunc = UserIdent_EnumDescriptor,
        .number = UserInfo_FieldNumber_Ident,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UserInfo__storage_, ident),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "plevel",
        .dataTypeSpecific.className = GPBStringifySymbol(UserPLevelInfo),
        .number = UserInfo_FieldNumber_Plevel,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(UserInfo__storage_, plevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "anchor",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_Anchor,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "mobile",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_Mobile,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(UserInfo__storage_, mobile),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "inviteCode",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_InviteCode,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(UserInfo__storage_, inviteCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserInfo class]
                                     rootClass:[UserUserdefRoot class]
                                          file:UserUserdefRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UserInfo_Ident_RawValue(UserInfo *message) {
  GPBDescriptor *descriptor = [UserInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserInfo_FieldNumber_Ident];
  return GPBGetMessageInt32Field(message, field);
}

void SetUserInfo_Ident_RawValue(UserInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [UserInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserInfo_FieldNumber_Ident];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - UserOneUser

@implementation UserOneUser

@dynamic uid;
@dynamic platform;
@dynamic socketId;
@dynamic gateIp;

typedef struct UserOneUser__storage_ {
  uint32_t _has_storage_[1];
  uint32_t uid;
  uint32_t platform;
  uint32_t socketId;
  NSString *gateIp;
} UserOneUser__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uid",
        .dataTypeSpecific.className = NULL,
        .number = UserOneUser_FieldNumber_Uid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserOneUser__storage_, uid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "platform",
        .dataTypeSpecific.className = NULL,
        .number = UserOneUser_FieldNumber_Platform,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserOneUser__storage_, platform),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "socketId",
        .dataTypeSpecific.className = NULL,
        .number = UserOneUser_FieldNumber_SocketId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserOneUser__storage_, socketId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "gateIp",
        .dataTypeSpecific.className = NULL,
        .number = UserOneUser_FieldNumber_GateIp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UserOneUser__storage_, gateIp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserOneUser class]
                                     rootClass:[UserUserdefRoot class]
                                          file:UserUserdefRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserOneUser__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\003\010\000\004\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserLoginRequest

@implementation UserLoginRequest

@dynamic uid;
@dynamic token;
@dynamic platform;
@dynamic traceId;

typedef struct UserLoginRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t uid;
  uint32_t platform;
  NSString *token;
  NSString *traceId;
} UserLoginRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uid",
        .dataTypeSpecific.className = NULL,
        .number = UserLoginRequest_FieldNumber_Uid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserLoginRequest__storage_, uid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = UserLoginRequest_FieldNumber_Token,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserLoginRequest__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "platform",
        .dataTypeSpecific.className = NULL,
        .number = UserLoginRequest_FieldNumber_Platform,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserLoginRequest__storage_, platform),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "traceId",
        .dataTypeSpecific.className = NULL,
        .number = UserLoginRequest_FieldNumber_TraceId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UserLoginRequest__storage_, traceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserLoginRequest class]
                                     rootClass:[UserUserdefRoot class]
                                          file:UserUserdefRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserLoginRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserLoginReply

@implementation UserLoginReply

@dynamic code;
@dynamic message;
@dynamic hasUser, user;
@dynamic traceId;
@dynamic loginCnt;

typedef struct UserLoginReply__storage_ {
  uint32_t _has_storage_[1];
  CommErrorType code;
  uint32_t loginCnt;
  NSString *message;
  UserInfo *user;
  NSString *traceId;
} UserLoginReply__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.enumDescFunc = CommErrorType_EnumDescriptor,
        .number = UserLoginReply_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserLoginReply__storage_, code),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "message",
        .dataTypeSpecific.className = NULL,
        .number = UserLoginReply_FieldNumber_Message,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserLoginReply__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(UserInfo),
        .number = UserLoginReply_FieldNumber_User,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserLoginReply__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "traceId",
        .dataTypeSpecific.className = NULL,
        .number = UserLoginReply_FieldNumber_TraceId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UserLoginReply__storage_, traceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "loginCnt",
        .dataTypeSpecific.className = NULL,
        .number = UserLoginReply_FieldNumber_LoginCnt,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UserLoginReply__storage_, loginCnt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserLoginReply class]
                                     rootClass:[UserUserdefRoot class]
                                          file:UserUserdefRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserLoginReply__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\004\007\000\005\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UserLoginReply_Code_RawValue(UserLoginReply *message) {
  GPBDescriptor *descriptor = [UserLoginReply descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserLoginReply_FieldNumber_Code];
  return GPBGetMessageInt32Field(message, field);
}

void SetUserLoginReply_Code_RawValue(UserLoginReply *message, int32_t value) {
  GPBDescriptor *descriptor = [UserLoginReply descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserLoginReply_FieldNumber_Code];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - UserLogoutRequest

@implementation UserLogoutRequest

@dynamic traceId;
@dynamic except;

typedef struct UserLogoutRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *traceId;
} UserLogoutRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "traceId",
        .dataTypeSpecific.className = NULL,
        .number = UserLogoutRequest_FieldNumber_TraceId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserLogoutRequest__storage_, traceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "except",
        .dataTypeSpecific.className = NULL,
        .number = UserLogoutRequest_FieldNumber_Except,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserLogoutRequest class]
                                     rootClass:[UserUserdefRoot class]
                                          file:UserUserdefRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserLogoutRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserLogoutReply

@implementation UserLogoutReply

@dynamic code;
@dynamic message;
@dynamic traceId;

typedef struct UserLogoutReply__storage_ {
  uint32_t _has_storage_[1];
  CommErrorType code;
  NSString *message;
  NSString *traceId;
} UserLogoutReply__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.enumDescFunc = CommErrorType_EnumDescriptor,
        .number = UserLogoutReply_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserLogoutReply__storage_, code),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "message",
        .dataTypeSpecific.className = NULL,
        .number = UserLogoutReply_FieldNumber_Message,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserLogoutReply__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "traceId",
        .dataTypeSpecific.className = NULL,
        .number = UserLogoutReply_FieldNumber_TraceId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserLogoutReply__storage_, traceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserLogoutReply class]
                                     rootClass:[UserUserdefRoot class]
                                          file:UserUserdefRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserLogoutReply__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UserLogoutReply_Code_RawValue(UserLogoutReply *message) {
  GPBDescriptor *descriptor = [UserLogoutReply descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserLogoutReply_FieldNumber_Code];
  return GPBGetMessageInt32Field(message, field);
}

void SetUserLogoutReply_Code_RawValue(UserLogoutReply *message, int32_t value) {
  GPBDescriptor *descriptor = [UserLogoutReply descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserLogoutReply_FieldNumber_Code];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - UserKickOutRequest

@implementation UserKickOutRequest

@dynamic uid;
@dynamic lastSid;
@dynamic lastPlatform;
@dynamic message;
@dynamic traceId;

typedef struct UserKickOutRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t uid;
  uint32_t lastSid;
  uint32_t lastPlatform;
  NSString *message;
  NSString *traceId;
} UserKickOutRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uid",
        .dataTypeSpecific.className = NULL,
        .number = UserKickOutRequest_FieldNumber_Uid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserKickOutRequest__storage_, uid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "lastSid",
        .dataTypeSpecific.className = NULL,
        .number = UserKickOutRequest_FieldNumber_LastSid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserKickOutRequest__storage_, lastSid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "lastPlatform",
        .dataTypeSpecific.className = NULL,
        .number = UserKickOutRequest_FieldNumber_LastPlatform,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserKickOutRequest__storage_, lastPlatform),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "message",
        .dataTypeSpecific.className = NULL,
        .number = UserKickOutRequest_FieldNumber_Message,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UserKickOutRequest__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "traceId",
        .dataTypeSpecific.className = NULL,
        .number = UserKickOutRequest_FieldNumber_TraceId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UserKickOutRequest__storage_, traceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserKickOutRequest class]
                                     rootClass:[UserUserdefRoot class]
                                          file:UserUserdefRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserKickOutRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\005\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserKickOut

@implementation UserKickOut

@dynamic code;
@dynamic message;
@dynamic traceId;

typedef struct UserKickOut__storage_ {
  uint32_t _has_storage_[1];
  CommErrorType code;
  NSString *message;
  NSString *traceId;
} UserKickOut__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.enumDescFunc = CommErrorType_EnumDescriptor,
        .number = UserKickOut_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserKickOut__storage_, code),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "message",
        .dataTypeSpecific.className = NULL,
        .number = UserKickOut_FieldNumber_Message,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserKickOut__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "traceId",
        .dataTypeSpecific.className = NULL,
        .number = UserKickOut_FieldNumber_TraceId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserKickOut__storage_, traceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserKickOut class]
                                     rootClass:[UserUserdefRoot class]
                                          file:UserUserdefRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserKickOut__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UserKickOut_Code_RawValue(UserKickOut *message) {
  GPBDescriptor *descriptor = [UserKickOut descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserKickOut_FieldNumber_Code];
  return GPBGetMessageInt32Field(message, field);
}

void SetUserKickOut_Code_RawValue(UserKickOut *message, int32_t value) {
  GPBDescriptor *descriptor = [UserKickOut descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserKickOut_FieldNumber_Code];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - UserLoginNotify

@implementation UserLoginNotify

@dynamic hasUser, user;
@dynamic loginTime;
@dynamic socketId;
@dynamic currentGateIp;
@dynamic traceId;

typedef struct UserLoginNotify__storage_ {
  uint32_t _has_storage_[1];
  uint32_t socketId;
  UserOneUser *user;
  NSString *currentGateIp;
  NSString *traceId;
  int64_t loginTime;
} UserLoginNotify__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(UserOneUser),
        .number = UserLoginNotify_FieldNumber_User,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserLoginNotify__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "loginTime",
        .dataTypeSpecific.className = NULL,
        .number = UserLoginNotify_FieldNumber_LoginTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserLoginNotify__storage_, loginTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "socketId",
        .dataTypeSpecific.className = NULL,
        .number = UserLoginNotify_FieldNumber_SocketId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserLoginNotify__storage_, socketId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "currentGateIp",
        .dataTypeSpecific.className = NULL,
        .number = UserLoginNotify_FieldNumber_CurrentGateIp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UserLoginNotify__storage_, currentGateIp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "traceId",
        .dataTypeSpecific.className = NULL,
        .number = UserLoginNotify_FieldNumber_TraceId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UserLoginNotify__storage_, traceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserLoginNotify class]
                                     rootClass:[UserUserdefRoot class]
                                          file:UserUserdefRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserLoginNotify__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\002\t\000\003\010\000\004\r\000\005\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserMsgNotify

@implementation UserMsgNotify

@dynamic userArray, userArray_Count;
@dynamic message;
@dynamic cmdId;
@dynamic gateType;

typedef struct UserMsgNotify__storage_ {
  uint32_t _has_storage_[1];
  uint32_t cmdId;
  int32_t gateType;
  NSMutableArray *userArray;
  NSData *message;
} UserMsgNotify__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userArray",
        .dataTypeSpecific.className = GPBStringifySymbol(UserOneUser),
        .number = UserMsgNotify_FieldNumber_UserArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UserMsgNotify__storage_, userArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "message",
        .dataTypeSpecific.className = NULL,
        .number = UserMsgNotify_FieldNumber_Message,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserMsgNotify__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "cmdId",
        .dataTypeSpecific.className = NULL,
        .number = UserMsgNotify_FieldNumber_CmdId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserMsgNotify__storage_, cmdId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "gateType",
        .dataTypeSpecific.className = NULL,
        .number = UserMsgNotify_FieldNumber_GateType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserMsgNotify__storage_, gateType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserMsgNotify class]
                                     rootClass:[UserUserdefRoot class]
                                          file:UserUserdefRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserMsgNotify__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\003\005\000\004\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
