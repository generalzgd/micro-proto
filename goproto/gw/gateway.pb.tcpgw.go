// Code generated by protoc-gen-grpc-tcpway. DO NOT EDIT.
// source: gw/gateway.proto

/*
Package gw is a tcp/ws proxy.

It translates protobuf/Json packet into gRPC APIs.
*/
package gw

import (
	"context"
	"encoding/json"
	"errors"
	"strings"
	"time"

	"github.com/generalzgd/comm-libs"
	"github.com/golang/protobuf/proto"
	"google.golang.org/grpc"
	"google.golang.org/grpc/metadata"

	"github.com/generalzgd/micro-proto/goproto/auth"
	"github.com/generalzgd/micro-proto/goproto/comm"
)

// define func

type transmit_Authorize_Handler func(*TransmitArgs, auth.AuthorizeClient) (proto.Message, error)

type registerHandler func(args *TransmitArgs) (err error)

type TransmitArgs struct {
	Method       string
	Endpoint     string
	Conn         *grpc.ClientConn
	MD           metadata.MD
	Data         []byte
	Codec        uint16
	Opts         []grpc.DialOption
	DoneCallback func(proto.Message)
	ctx          context.Context
}

var (
	// definePrefix =
	// tag @id to package.TargetService/Method map
	id2meth = map[uint16]string{}

	meth2id = map[string]uint16{}

	id2struct = map[uint16]func() proto.Message{}

	structName2id = map[string]uint16{}

	transmit_Authorize_Map = map[string]transmit_Authorize_Handler{}

	serviceMap = map[string]registerHandler{}
)

func init() {
	// id2meth

	id2meth[8193] = "gw.Authorize/Login"
	id2meth[8195] = "gw.Authorize/Logout"
	id2meth[6173] = "gw.Authorize/GetUserInfo"

	// meth2id
	for k, v := range id2meth {
		meth2id[v] = k
	}
	// id2struct
	id2struct[6172] = func() proto.Message { return &imdef.ImError{} } // todo 这行为工具写死的代码,应该改成模板
	id2struct[8197] = func() proto.Message { return &comm.HfError{} }

	id2struct[8193] = func() proto.Message { return &user.LoginRequest{} }
	id2struct[8194] = func() proto.Message { return &user.LoginReply{} }

	id2struct[8195] = func() proto.Message { return &user.LogoutRequest{} }
	id2struct[8196] = func() proto.Message { return &user.LogoutReply{} }

	id2struct[6173] = func() proto.Message { return &user.GetUserInfoRequest{} }
	id2struct[6174] = func() proto.Message { return &user.GetUserInfoReply{} }

	// structName2id
	structName2id["ImError"] = 6172 // todo 这行为工具写死的代码,应该改成模板
	structName2id["HfError"] = 8197

	structName2id["LoginRequest"] = 8193
	structName2id["LoginReply"] = 8194

	structName2id["LogoutRequest"] = 8195
	structName2id["LogoutReply"] = 8196

	structName2id["GetUserInfoRequest"] = 6173
	structName2id["GetUserInfoReply"] = 6174

	// todo something handler

	transmit_Authorize_Map["gw.Authorize/Login"] = request_Authorize_Login
	transmit_Authorize_Map["gw.Authorize/Logout"] = request_Authorize_Logout
	transmit_Authorize_Map["gw.Authorize/GetUserInfo"] = request_Authorize_GetUserInfo

	serviceMap["gw.Authorize"] = register_Authorize_Transmitor
}

func DecodeBytes(data []byte, codec uint16, inst proto.Message) error {
	if codec == 0 {
		return proto.Unmarshal(data, inst)
	} else if codec == 1 {
		return json.Unmarshal(data, inst)
	}
	return errors.New("codec type error")
}

func EncodeBytes(codec uint16, inst proto.Message) ([]byte, error) {
	if codec == 0 {
		return proto.Marshal(inst)
	} else if codec == 1 {
		return json.Marshal(inst)
	}
	return nil, errors.New("codec type error")
}

// get meth(package.TargetService/Method) by id(cmdid)
func GetMethById(id uint16) string {
	return id2meth[id]
}

func GetIdByMeth(meth string) uint16 {
	return meth2id[meth]
}

// 根据@id/@upid/@downid标签获取对应方法的请求参数对象
func GetMsgObjById(id uint16) (proto.Message, bool) {
	if f, ok := id2struct[id]; ok {
		return f(), true
	}
	return nil, false
}

func GetIdByMsgObj(obj proto.Message) uint16 {
	name := comm_libs.GetStructName(obj)
	return structName2id[name]
}

func ParseMethod(method string) (string, string, string, error) {
	method = strings.Trim(method, "/")
	dotIdx := strings.Index(method, ".")
	slashIdx := strings.Index(method, "/")
	if dotIdx < 1 || slashIdx < 1 || dotIdx > slashIdx {
		return "", "", "", errors.New("method must be type of 'package.ServiceName/Method'")
	}
	packageName := method[:dotIdx]
	serviceName := strings.Trim(method[dotIdx:slashIdx], ".")
	methodName := strings.Trim(method[slashIdx:], "/")
	return packageName, serviceName, methodName, nil
}

// define call enter point
func RegisterTransmitor(args *TransmitArgs) error {
	if len(args.Method) < 1 || len(args.Endpoint) < 1 || len(args.MD) < 1 || args.DoneCallback == nil {
		return errors.New("transmit args empty")
	}

	packageName, serviceName, _, err := ParseMethod(args.Method)
	if err != nil {
		return err
	}
	packageService := packageName + "." + serviceName
	if handler, ok := serviceMap[packageService]; ok {
		err := handler(args)
		return err
	}
	return errors.New("method not register yet")
}

// registor single service enter point

// *********************************************************************************
// 注册Gateway传输转换入口
// 上行
// @import github.com/generalzgd/micro-proto/goproto/auth:3 需要额外增加的包,1tcp需要加,2http需要加,3都要加
// @import github.com/generalzgd/micro-proto/goproto/comm:1 需要额外增加的包
func register_Authorize_Transmitor(args *TransmitArgs) (err error) {
	if args.Conn == nil {
		conn, err := grpc.Dial(args.Endpoint, args.Opts...)
		if err != nil {
			return err
		}
		defer conn.Close()
		args.Conn = conn
	}

	ctx := context.Background()
	ctx, _ = context.WithTimeout(ctx, 5*time.Second)
	ctx = metadata.NewOutgoingContext(ctx, args.MD)
	args.ctx = ctx
	//
	client := auth.NewAuthorizeClient(args.Conn)
	handler, ok := transmit_Authorize_Map[args.Method]
	if !ok {
		return errors.New("method error")
	}
	res, err := handler(args, client)
	if err != nil {
		return err
	}
	args.DoneCallback(res)
	return nil
}

// 注册Authorize/Login 传输方法入口
// 登录校验用户
// @tarpkg auth 所在目录,对应@import的某行
func request_Authorize_Login(args *TransmitArgs, client auth.AuthorizeClient) (proto.Message, error) {
	protoReq := &user.LoginRequest{}
	if err := DecodeBytes(args.Data, args.Codec, protoReq); err != nil {
		return nil, errors.New("codec err[" + err.Error() + "]")
	}
	reply, err := client.Login(args.ctx, protoReq)
	if err != nil {
		return nil, errors.New("call err[" + err.Error() + "]")
	}
	return reply, nil
}

// 注册Authorize/Logout 传输方法入口
// 登出
// @tarpkg auth 所在目录
func request_Authorize_Logout(args *TransmitArgs, client auth.AuthorizeClient) (proto.Message, error) {
	protoReq := &user.LogoutRequest{}
	if err := DecodeBytes(args.Data, args.Codec, protoReq); err != nil {
		return nil, errors.New("codec err[" + err.Error() + "]")
	}
	reply, err := client.Logout(args.ctx, protoReq)
	if err != nil {
		return nil, errors.New("call err[" + err.Error() + "]")
	}
	return reply, nil
}

// 注册Authorize/GetUserInfo 传输方法入口
// 获得用户信息
// @tarpkg auth 所在目录
func request_Authorize_GetUserInfo(args *TransmitArgs, client auth.AuthorizeClient) (proto.Message, error) {
	protoReq := &user.GetUserInfoRequest{}
	if err := DecodeBytes(args.Data, args.Codec, protoReq); err != nil {
		return nil, errors.New("codec err[" + err.Error() + "]")
	}
	reply, err := client.GetUserInfo(args.ctx, protoReq)
	if err != nil {
		return nil, errors.New("call err[" + err.Error() + "]")
	}
	return reply, nil
}
